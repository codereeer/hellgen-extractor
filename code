(function() {
  'use strict';

  if (document.querySelector('.hellGUI')) return;

  const style = document.createElement('style');
  style.textContent = `
    @keyframes popIn { from { transform: scale(0.92) translateY(-8px); opacity: 0; } to { transform: scale(1) translateY(0); opacity: 1; } }
    @keyframes glowPulse { 0%, 100% { box-shadow: 0 0 8px rgba(79,195,247,0.4); } 50% { box-shadow: 0 0 20px rgba(79,195,247,0.7); } }
    @keyframes slideDown { from { height: 0; opacity: 0; transform: translateY(-10px); } to { height: var(--full-height); opacity: 1; transform: translateY(0); } }
    @keyframes slideUp { from { height: var(--full-height); opacity: 1; transform: translateY(0); } to { height: 0; opacity: 0; transform: translateY(-10px); } }
    @keyframes ripple { 0% { transform: scale(0); opacity: 1; } 100% { transform: scale(2.5); opacity: 0; } }
    @keyframes shimmer { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }

    * { scrollbar-width: thin; scrollbar-color: rgba(79,195,247,0.5) transparent; }
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: rgba(79,195,247,0.4); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(79,195,247,0.6); }

    .hellGUI {
      position: fixed; top: 16px; right: 16px; width: 280px; min-height: 44px; max-height: 380px;
      background: rgba(24, 26, 31, 0.95); backdrop-filter: blur(20px) saturate(1.2);
      border: 1px solid rgba(79,195,247,0.2); border-radius: 16px;
      color: #e8f4fd; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      box-shadow: 0 20px 60px rgba(0,150,255,0.25), 0 0 0 1px rgba(79,195,247,0.1), inset 0 1px 0 rgba(255,255,255,0.05);
      display: flex; flex-direction: column; overflow: hidden; z-index: 999999;
      animation: popIn 0.45s cubic-bezier(0.34, 1.56, 0.64, 1);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .hellGUI.minimized { min-height: 44px; max-height: 44px; }

    .hellHeader {
      display: flex; align-items: center; justify-content: space-between; padding: 12px 16px;
      background: linear-gradient(135deg, rgba(79,195,247,0.08), rgba(33,150,243,0.04));
      border-bottom: 1px solid rgba(79,195,247,0.15); cursor: pointer;
      position: relative; overflow: hidden; transition: all 0.25s ease;
    }
    .hellHeader::before {
      content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
      background: linear-gradient(90deg, transparent, rgba(79,195,247,0.1), transparent);
      transition: left 0.6s;
    }
    .hellHeader:hover::before { left: 100%; }
    .hellHeader:hover { background: rgba(79,195,247,0.16); transform: translateY(-1px); }

    .hellHeaderTitle { display: flex; align-items: center; flex: 1; min-width: 0; }
    .hellTitle {
      font-weight: 700; font-size: 14px;
      background: linear-gradient(135deg, #4fc3f7, #81d4fa, #4fc3f7);
      background-size: 200% 200%; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text; animation: shimmer 3s infinite;
      margin: 0; letter-spacing: 0.3px; text-shadow: 0 0 10px rgba(79,195,247,0.3);
    }
    .hellBadge {
      background: linear-gradient(135deg, #0f4c3a, #117a65, #26a69a); color: #b2fab4;
      border-radius: 12px; padding: 4px 10px; font-size: 11px; font-weight: 700; margin-left: 12px;
      box-shadow: 0 4px 12px rgba(16, 76, 58, 0.4); transition: all 0.3s ease;
      min-width: 28px; text-align: center; position: relative; overflow: hidden;
    }
    .hellBadge::after {
      content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      transition: left 0.5s;
    }
    .hellBadge:hover::after { left: 100%; }
    .hellBadge.new { animation: glowPulse 1.5s infinite; box-shadow: 0 0 15px rgba(178,250,180,0.6); }

    .hellMinimize {
      width: 28px; height: 28px; border: none;
      background: linear-gradient(135deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
      border-radius: 50%; color: #4fc3f7; font-size: 14px; font-weight: bold; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      transition: all 0.3s cubic-bezier(0.4,0,0.2,1); backdrop-filter: blur(10px);
      position: relative; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    .hellMinimize::before {
      content: ''; position: absolute; top: 50%; left: 50%; width: 0; height: 0;
      background: rgba(79,195,247,0.4); border-radius: 50%;
      transform: translate(-50%, -50%); transition: all 0.6s;
    }
    .hellMinimize:active::before { width: 300px; height: 300px; }
    .hellMinimize:hover {
      background: linear-gradient(135deg, rgba(79,195,247,0.4), rgba(79,195,247,0.2));
      transform: scale(1.08) rotate(180deg); box-shadow: 0 6px 20px rgba(79,195,247,0.4);
    }
    .hellMinimize.minimized::after { content: '↗'; font-size: 12px; }

    .hellContent {
      flex: 1; overflow: hidden; display: flex; flex-direction: column;
      transition: all 0.4s cubic-bezier(0.4,0,0.2,1);
    }
    .hellGUI.minimized .hellContent { display: none; }

    .hellList {
      flex: 1; overflow-y: auto; background: rgba(30,30,36,0.7); margin: 12px 12px 0;
      border: 1px solid rgba(79,195,247,0.18); border-radius: 12px; padding: 12px;
      font-size: 12px; min-height: 120px; position: relative;
    }
    .hellList::before {
      content: ''; position: absolute; top: 0; left: 0; right: 0; height: 1px;
      background: linear-gradient(90deg, transparent, rgba(79,195,247,0.4), transparent);
    }
    .hellRow {
      display: flex; align-items: center; justify-content: space-between; padding: 10px 14px;
      background: linear-gradient(135deg, rgba(50,50,60,0.8), rgba(60,60,70,0.6));
      border-radius: 10px; margin-bottom: 10px; cursor: pointer; transition: all 0.3s cubic-bezier(0.4,0,0.2,1);
      border: 1px solid rgba(79,195,247,0.12); position: relative; overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    .hellRow::before {
      content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 0;
      background: linear-gradient(90deg, transparent, rgba(79,195,247,0.15), transparent);
      transition: width 0.5s ease; z-index: 0;
    }
    .hellRow:hover::before { width: 100%; }
    .hellRow:hover {
      transform: translateY(-3px) scale(1.02);
      box-shadow: 0 12px 35px rgba(79,195,247,0.35);
      border-color: rgba(79,195,247,0.4);
    }

    .hellBtn {
      position: relative; overflow: hidden; border: none; border-radius: 8px; font-size: 11px;
      font-weight: 700; cursor: pointer; transition: all 0.35s cubic-bezier(0.4,0,0.2,1);
      backdrop-filter: blur(12px); z-index: 2; text-transform: uppercase; letter-spacing: 0.5px;
    }
    .hellBtn::before {
      content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.25), transparent);
      transition: left 0.6s;
    }
    .hellBtn:hover::before { left: 100%; }
    .hellBtn.copy {
      background: linear-gradient(135deg, #26a69a, #4db6ac, #26c6da); color: white;
      padding: 8px 16px; min-width: 56px; box-shadow: 0 6px 20px rgba(38,166,154,0.5);
    }
    .hellBtn.copy:hover {
      background: linear-gradient(135deg, #4caf50, #66bb6a, #81c784);
      transform: scale(1.1) translateY(-2px); box-shadow: 0 10px 30px rgba(76,175,80,0.6);
    }
    .hellBtn.del {
      background: linear-gradient(135deg, #ef5350, #f44336, #e57373); color: white;
      width: 28px; height: 28px; padding: 0; margin-left: 6px; box-shadow: 0 6px 20px rgba(239,83,80,0.5);
    }
    .hellBtn.del:hover {
      background: linear-gradient(135deg, #e53935, #d32f2f, #c62828);
      transform: scale(1.2) rotate(90deg); box-shadow: 0 10px 30px rgba(229,57,53,0.7);
    }
    .hellBtn.copied {
      background: linear-gradient(135deg, #4caf50, #66bb6a, #81c784) !important;
      animation: glowPulse 0.8s infinite; transform: scale(1.05);
    }

    .hellText {
      flex: 1; margin: 0 14px; word-break: break-all; font-family: 'SF Mono', Monaco, Consolas, monospace;
      font-size: 11.5px; z-index: 2; line-height: 1.3; letter-spacing: -0.02em;
    }

    .hellControls {
      padding: 0 14px 14px; font-size: 11px; color: #b0bec5;
      border-top: 1px solid rgba(79,195,247,0.12); margin-top: 8px;
    }
    .hellControls label {
      display: flex; align-items: center; margin-bottom: 10px; cursor: pointer;
      padding: 6px 4px; border-radius: 6px; transition: all 0.25s; position: relative;
    }
    .hellControls label::before {
      content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 4px;
      background: rgba(79,195,247,0.3); border-radius: 6px 0 0 6px; transform: scaleY(0);
      transition: transform 0.3s;
    }
    .hellControls label:hover::before { transform: scaleY(1); }
    .hellControls label:hover {
      color: #e8f4fd; background: rgba(79,195,247,0.08); transform: translateX(6px);
    }
    .hellControls input[type="checkbox"] {
      accent-color: #4fc3f7; transform: scale(1.2); margin-right: 10px;
      width: 18px; height: 18px; cursor: pointer; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
    }
    .hellDelayRow {
      display: flex; align-items: center; margin: 12px 0; font-weight: 600; padding: 8px;
      background: rgba(79,195,247,0.05); border-radius: 8px; border: 1px solid rgba(79,195,247,0.15);
    }
    input[type="number"] {
      width: 52px; padding: 8px 10px; margin: 0 10px; border: 1px solid rgba(79,195,247,0.4);
      border-radius: 8px; background: linear-gradient(135deg, rgba(20,25,30,0.9), rgba(30,35,40,0.8));
      color: #fff; font-size: 12px; font-weight: 600; transition: all 0.3s;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    input[type="number"]:focus {
      outline: none; border-color: #4fc3f7; box-shadow: 0 0 0 3px rgba(79,195,247,0.25), 0 4px 15px rgba(79,195,247,0.2);
      transform: scale(1.02);
    }

    #timer {
      margin-top: 14px; padding: 12px 16px; text-align: center; border-radius: 10px;
      background: linear-gradient(135deg, rgba(79,195,247,0.15), rgba(79,195,247,0.06));
      border: 1px solid rgba(79,195,247,0.3); font-weight: 800; font-size: 13px;
      color: #4fc3f7; letter-spacing: 1px; animation: glowPulse 2.5s infinite;
      box-shadow: 0 4px 20px rgba(79,195,247,0.2), inset 0 1px 0 rgba(255,255,255,0.15);
      position: relative; overflow: hidden;
    }
    #timer::before {
      content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      animation: shimmer 2s infinite;
    }
    .empty-state {
      color: #666; text-align: center; padding: 28px 16px; font-style: italic;
      font-size: 12px; display: flex; flex-direction: column; align-items: center; gap: 12px;
      background: rgba(100,100,120,0.1);
    }
  `;
  document.head.appendChild(style);

  let combos = JSON.parse(localStorage.getItem('hellgen_clean_unverified_combos') || '[]');
  let settings = JSON.parse(localStorage.getItem('hellgen_settings') || '{}');
  settings.selfDestruct ??= false; settings.delay ??= 5; settings.autoNext ??= false; settings.unverifiedOnly ??= true;
  let isMinimized = localStorage.getItem('hellgen_minimized') === 'true';

  const saveSettings = () => {
    localStorage.setItem('hellgen_settings', JSON.stringify(settings));
    localStorage.setItem('hellgen_minimized', isMinimized.toString());
  };

  const gui = document.createElement('div');
  gui.className = `hellGUI ${isMinimized ? 'minimized' : ''}`;
  gui.innerHTML = `
    <div class="hellHeader">
      <div class="hellHeaderTitle">
        <div class="hellTitle">Hellgen Combos</div>
        <div class="hellBadge" id="comboCount">0</div>
      </div>
      <button class="hellMinimize" id="minimizeBtn" title="${isMinimized ? 'Expand' : 'Minimize'}">${isMinimized ? '↗' : '−'}</button>
    </div>
    <div class="hellContent">
      <div class="hellList" id="comboList"></div>
      <div class="hellControls">
        <label><input type="checkbox" id="sd"> Auto-delete</label>
        <label><input type="checkbox" id="autoNext"> Auto-Next</label>
        <label><input type="checkbox" id="unverified"> Unverified Only</label>
        <div class="hellDelayRow">
          Delay: <input id="delay" type="number" min="1" max="30" value="${settings.delay}">s
        </div>
        <div id="timer">READY</div>
      </div>
    </div>
  `;
  document.body.appendChild(gui);

  const minimizeBtn = gui.querySelector('#minimizeBtn');
  const header = gui.querySelector('.hellHeader');

  function toggleMinimize() {
    isMinimized = !isMinimized;
    gui.classList.toggle('minimized', isMinimized);
    minimizeBtn.textContent = isMinimized ? '↗' : '−';
    minimizeBtn.title = isMinimized ? 'Expand' : 'Minimize';
    saveSettings();
  }

  minimizeBtn.onclick = (e) => { e.stopPropagation(); toggleMinimize(); };
  header.onclick = toggleMinimize;

  const list = gui.querySelector('#comboList');
  const counter = gui.querySelector('#comboCount');
  const sd = gui.querySelector('#sd'), autoNext = gui.querySelector('#autoNext'),
        unverified = gui.querySelector('#unverified'), delayInput = gui.querySelector('#delay'),
        timerDiv = gui.querySelector('#timer');

  sd.checked = settings.selfDestruct; autoNext.checked = settings.autoNext;
  unverified.checked = settings.unverifiedOnly; delayInput.value = settings.delay;

  sd.onchange = () => { settings.selfDestruct = sd.checked; saveSettings(); };
  autoNext.onchange = () => { settings.autoNext = autoNext.checked; saveSettings(); };
  unverified.onchange = () => { settings.unverifiedOnly = unverified.checked; saveSettings(); };
  delayInput.onchange = () => {
    settings.delay = Math.max(1, Math.min(30, +delayInput.value));
    saveSettings();
  };

  function updateList() {
    list.innerHTML = '';
    const count = combos.length;
    counter.textContent = count;
    counter.classList.toggle('new', count > 0);

    if (!count) {
      list.innerHTML = '<div class="empty-state">No combos yet<br><small>Waiting for unverified results...</small></div>';
      return;
    }

    combos.slice(0, 10).forEach((combo, i) => {
      const row = document.createElement('div');
      row.className = 'hellRow';

      const del = document.createElement('button');
      del.className = 'hellBtn del';
      del.innerHTML = '×';
      del.onclick = e => {
        e.stopPropagation();
        combos.splice(i, 1);
        localStorage.setItem('hellgen_clean_unverified_combos', JSON.stringify(combos));
        updateList();
      };

      const txt = document.createElement('span');
      txt.className = 'hellText';
      txt.textContent = combo;

      const copy = document.createElement('button');
      copy.className = 'hellBtn copy';
      copy.textContent = 'Copy';
      copy.onclick = async e => {
        e.stopPropagation();
        await navigator.clipboard.writeText(combo);
        copy.classList.add('copied');
        copy.textContent = '✓';
        setTimeout(() => {
          copy.classList.remove('copied');
          copy.textContent = 'Copy';
        }, 1400);

        if (settings.selfDestruct) {
          combos.splice(i, 1);
          localStorage.setItem('hellgen_clean_unverified_combos', JSON.stringify(combos));
          updateList();
        }
      };

      row.append(del, txt, copy);
      list.appendChild(row);
    });
  }

  let currentTimer = null, isWaiting = false;
  function findGenerateButton() {
    return [...document.querySelectorAll('button, [role="button"], .btn')]
      .find(b => {
        const text = b.textContent?.toLowerCase().trim();
        return text?.includes('generate another') || text?.includes('gen another');
      });
  }

  function startTimer(button) {
    if (currentTimer || isWaiting || !settings.autoNext) return;
    isWaiting = true;
    let timeLeft = settings.delay;
    timerDiv.textContent = `${timeLeft}s`;
    timerDiv.style.color = '#ffeb3b';

    currentTimer = setInterval(() => {
      timeLeft--;
      timerDiv.textContent = `${timeLeft}s`;
      if (timeLeft <= 0) {
        clearInterval(currentTimer);
        currentTimer = null;
        isWaiting = false;
        timerDiv.textContent = 'FIRED!';
        timerDiv.style.color = '#4caf50';

        button?.scrollIntoView({ behavior: 'smooth', block: 'center' });
        button?.click();

        setTimeout(() => {
          timerDiv.textContent = 'READY';
          timerDiv.style.color = '#4fc3f7';
        }, 1800);
      }
    }, 1000);
  }

  const comboRegex = /combo:([\S]+):([\S]+?)(?=\s*cooldown:|\s*$)/gi;
  const verifiedNoRegex = /Verified\s*:\s*No/i;

  function extractCombos(text) {
    let match, found = [];
    while ((match = comboRegex.exec(text)) !== null) {
      let username = match[1].trim();
      let password = match[2].trim().replace(/\s*cooldown.*$/i, '');
      if (/roblox$/i.test(password)) password = password.slice(0, -6);
      const combo = `${username}:${password}`;

      if (combos.includes(combo)) continue;

      const context = text.slice(Math.max(0, match.index - 600), match.index + match[0].length + 600);
      const isUnverified = verifiedNoRegex.test(context);

      if (!settings.unverifiedOnly || isUnverified) {
        combos.unshift(combo);
        found.push(combo);
      }
    }

    if (found.length) {
      if (combos.length > 100) combos = combos.slice(0, 100);
      localStorage.setItem('hellgen_clean_unverified_combos', JSON.stringify(combos));
      updateList();
    }
    return found;
  }

  const observer = new MutationObserver(mutations => {
    mutations.forEach(mutation => {
      mutation.addedNodes.forEach(node => {
        if (node.nodeType === 3) extractCombos(node.textContent || '');
        else if (node.nodeType === 1 && node.textContent) extractCombos(node.textContent);
      });
      if (mutation.type === 'characterData') extractCombos(mutation.target.textContent || '');
    });

    const button = findGenerateButton();
    if (button && !isWaiting && !currentTimer) startTimer(button);
  });

  if (document.body) {
    observer.observe(document.body, { childList: true, subtree: true, characterData: true });
    extractCombos(document.body.innerText || '');
  }

  setInterval(() => {
    extractCombos(document.body?.innerText || '');
    const button = findGenerateButton();
    if (button && !isWaiting && !currentTimer) startTimer(button);
  }, 1200);

  updateList();
})();
